"""
"""

from math import pi
import numpy
import random

from topo import learningfn,numbergen,transferfn,pattern,projection,responsefn,sheet

import topo.learningfn.optimized
import topo.learningfn.projfn
import topo.transferfn.optimized
import topo.pattern.random
import topo.pattern.image
import topo.responsefn.optimized
import topo.sheet.lissom
import topo.sheet.optimized


### Specify weight initialization, response function, and learning function
projection.CFProjection.cf_shape=pattern.Disk(smoothing=0.0)
projection.CFProjection.weights_generator=pattern.Constant()
projection.CFProjection.response_fn=responsefn.optimized.CFPRF_DotProduct_opt()
projection.CFProjection.learning_fn=learningfn.optimized.CFPLF_Hebbian_opt()
projection.CFProjection.weights_output_fns=[transferfn.optimized.CFPOF_DivisiveNormalizeL1_opt()]

from topo.misc.commandline import global_params as params
params.add(
    density=param.Number(default=24.0,bounds=(0,None),
        inclusive_bounds=(False,True),doc="""
        The nominal_density to use for the retina."""),

    cortex_density=param.Number(default=48.0,bounds=(0,None),
        inclusive_bounds=(False,True),doc="""
        The nominal_density to use for V1."""),

    lgn_strength = param.Number(default = 1.8, doc = """
        The strength to use for LGN afferent connections."""),

    duration = param.Number(default = 0.225, doc = """
        The duration to present the image."""),

    ids = param.Number(default = 4.0))

eyes=['']
center_polarities=['On','Off']
rgb_cone_types = ['Red', 'Green', 'Blue']
cone_probabilities = [0.53, 0.38, 0.09] # cone distributions from Roorda et al.: 482 R / 344 G / 78 B

default_image_density=locals().get('default_image_density', params.density)

input_type=pattern.image.FileImage
scalingfactor=[1.4*0.9,1.4,1.4*0.97] # from Judah's PhD
surround_radius_in_cells = 6.0 / 2

ids=params.ids
num_aff = len(center_polarities) * len(eyes)

for e in eyes:
    seed = (random.randint(1, 500), random.randint(1, 500))
    thresholds = 0, 0
    
    for cone in rgb_cone_types:
        image_filenames=["/group/project/csng/images/mcgill/foliage_b/%02d_%d.png"%(i,rgb_cone_types.index(cone)) for i in xrange(1,26)]
        inputs=[input_type(filename=f, size=10.0, cache_image=False,
                           x=numbergen.UniformRandom(lbound=-0.75,ubound=0.75,seed=12),
                           y=numbergen.UniformRandom(lbound=-0.75,ubound=0.75,seed=34),
                           orientation=numbergen.UniformRandom(lbound=-pi,ubound=pi,seed=56),
                           scale=2.0-numbergen.UniformRandom(lbound=0,ubound=2,seed=78)*scalingfactor[rgb_cone_types.index(cone)] \
                           if e=='Right' else numbergen.UniformRandom(lbound=0,ubound=2,seed=78)*scalingfactor[rgb_cone_types.index(cone)])
                for f in image_filenames]

        topo.sim[e+cone+'Image']=sheet.GeneratorSheet(
            nominal_density=default_image_density,
            input_generator=pattern.Selector(generators=inputs),
            period=1.0, phase=0.05,
            nominal_bounds=sheet.BoundingBox(radius=0.5 + 0.27083 + 0.375))

    cone_density = 14.0
    topo.sim[e+'Cones']=sheet.CFSheet(
        precedence = 0.4,
        nominal_density = params.density * cone_density,
        nominal_bounds = sheet.BoundingBox(radius=0.5 + 0.27083 + 0.375),
        output_fns = [transferfn.CartesianToHex(hex_width = cone_density)],
        measure_maps=False)

    for cone in rgb_cone_types:
        pattern.random.seed(seed)
        thresholds = thresholds[1], thresholds[1] + cone_probabilities[rgb_cone_types.index(cone)]
        topo.sim.connect(e+cone+'Image', e+'Cones', delay=0.05,
             name=cone+'Afferent', connection_type=projection.OneToOneProjection,
             weights_generator = pattern.random.UniformRandom(output_fns=[transferfn.BinaryInterval(
                                                              lower_bound = thresholds[0], upper_bound = thresholds[1])]))

topo.sim['V1'] = sheet.SettlingCFSheet(
    nominal_density=locals().get('default_density', params.cortex_density),tsettle=9,
    nominal_bounds=sheet.BoundingBox(radius=0.5),
    output_fns=[transferfn.PiecewiseLinear(lower_bound=0.076,upper_bound=0.626)])

surround_radius = surround_radius_in_cells / topo.sim[eyes[0] + 'Cones'].xdensity * cone_density
surroundg = pattern.Gaussian(size=surround_radius, aspect_ratio=1.0, output_fns=[transferfn.DivisiveNormalizeL1()])
for e in eyes:
    for polarity in center_polarities:
        topo.sim[e + 'RGC' + polarity]=sheet.CFSheet(
            nominal_density=params.density,
            nominal_bounds=sheet.BoundingBox(radius=0.5 + 0.27083),
            output_fns=[transferfn.PiecewiseLinear(lower_bound=0.0,upper_bound=1.0)],
            measure_maps=False)

        strength = 4.7 
        topo.sim.connect(e + 'Cones', e + 'RGC' + polarity, delay=0.05,
            connection_type = projection.OneToOneProjection, 
            strength = strength * (-1)**center_polarities.index(polarity),
            name = 'AfferentCenter')
        topo.sim.connect(e + 'Cones', e + 'RGC' + polarity, delay=0.05,
            connection_type = projection.CFProjection, 
            strength = strength * (-1)**(1 + center_polarities.index(polarity)),
            nominal_bounds_template=sheet.BoundingBox(radius = 0.375),
            name = 'AfferentSurround', weights_generator = surroundg)
            
        topo.sim.connect(e + 'RGC' + polarity, 'V1', delay=0.05, dest_port=('Activity', 'JointNormalize', 'Afferent'),
                         connection_type=projection.CFProjection, strength=1.0, name= e + 'RGC' + polarity + 'Afferent',
                         weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.27083),
                         nominal_bounds_template=sheet.BoundingBox(radius=0.27083),
                         learning_rate=0.9590/num_aff/ids)
            

topo.sim.connect('V1','V1',delay=0.05,name='LateralExcitatory',
                 connection_type=projection.ResizableCFProjection,strength=1.2,
                 weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.10417),
                 nominal_bounds_template=sheet.BoundingBox(radius=0.10417),learning_rate=2.55528/ids)

topo.sim.connect('V1','V1',delay=0.05,name='LateralInhibitory',
                 connection_type=projection.CFProjection,strength=-1.75,
                 weights_generator=pattern.random.GaussianCloud(gaussian_size=2*0.22917),
                 nominal_bounds_template=sheet.BoundingBox(radius=0.22917),learning_rate=1.80873/ids/5)


### Actions scheduled to occur as the simulation proceeds.
sheet.lissom.schedule_events("topo.sim['V1']",st=1.0/2.0,
                             aff_name="Afferent",ids=ids,
                             increase_inhibition=True)

# default locations for model editor
cones=[]
images=[]
rgc = []
v1 = [None] * 4 + ['V1'] + [None] * 4
for e in eyes:
    rgc += [None] * 2 + [e + 'RGCOn'] + [None] * 3 + [e + 'RGCOff'] + [None] * 2
    for cone in rgb_cone_types:
        images += [None, e + cone + 'Image', None]
    cones += [None] * 4 + [e + 'Cones'] + [None] * 4
topo.sim.grid_layout([v1, rgc, cones, images], xstep=70/len(eyes), ystep=200, item_scale=0.75/len(eyes))


### Set up appropriate defaults for analysis

# Measure feature maps based on unthresholded initial response for
# speed and reliability
from topo.analysis.featureresponses import MeasureResponseCommand
MeasureResponseCommand.duration=params.duration
MeasureResponseCommand.apply_output_fns=False
